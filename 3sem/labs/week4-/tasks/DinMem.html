<!DOCTYPE html>
<html lang="ru">
<head>
        <meta charset="utf-8" />
        <title>Динамическая память</title>
        <link rel="stylesheet" href="http://judge.mipt.ru/mipt_cs_on_cpp/theme/css/main.css" />
        <link rel="icon" type="image/png" href="http://judge.mipt.ru/mipt_cs_on_cpp/favicon.png" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <div id="wrap">
            <header id="banner" class="body">
                    <!--img src="http://judge.mipt.ru/mipt_cs_on_cpp/images/logo.svg" class="logo" /-->
                    <nav><ul>
                        <li><a href="http://judge.mipt.ru/mipt_cs_on_cpp">Главная</a></li>
                    </ul></nav>
            </header><!-- /#banner -->
            <div id="main"
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://judge.mipt.ru/mipt_cs_on_cpp/labs/lab4.html" rel="bookmark"
           title="Permalink to Динамическая память">Динамическая память</a></h1>
    </header>
      <nav class="toc">
      <div class="toc" id="">

<ul class="simple">
<li><a class="reference internal" href="#id3" id="id11">Введение</a></li>
<li><a class="reference internal" href="#id4" id="id12">Выделение и освобождение участков памяти</a></li>
<li><a class="reference internal" href="#id5" id="id13">Утечка памяти</a></li>
<li><a class="reference internal" href="#id6" id="id14">Ошибка сегментации</a></li>
<li><a class="reference internal" href="#valgrind" id="id15">Valgrind</a></li>
<li><a class="reference internal" href="#addresssanitizer" id="id16">AddressSanitizer</a></li>
<li><a class="reference internal" href="#id7" id="id17">Задания</a><ul>
<li><a class="reference internal" href="#id8" id="id18">Умнножение матрицу</a></li>
<li><a class="reference internal" href="#id9" id="id19">Треугольник Паскаля</a></li>
</ul>
</li>
</ul>
</div>
      </nav>
      <br/>
      <br/>
    
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id11">Введение</a></h2>
<p>При запуске программы на компьютере ей сразу выделяется определённый объём оперативной памяти. Если же программе на некоторый период необходима дополнительная оперативная память, то её можно динамически выделить, а после — освободить, с помощью специальных инструкций. Это позволяет программе контролировать и корректировать объём используемой памяти во время работы и, следовательно, создавать программы способные обрабатывать большие объёмы данных, обходя ограничения физической памяти машины.</p>
<p>Доступ к динамической памяти осуществляется посредством указателей, т. е.  для манипуляции с динамической памятью, необходимо сохранить адрес выделенной области, и уже через него работать с памятью (читать и записывать данные).</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id12">Выделение и освобождение участков памяти</a></h2>
<p>Для выделения динамической памяти в С++ используется оператор <code>new</code>:</p>
<ol class="arabic simple">
<li>Оператор <code>new</code>. Выделяет для объекта память из области свободной памяти. После встречи компилятором ключевого слова <code>new</code> им генерируется <em>вызов конструктора класса</em>.</li>
<li>Оператор <code>new[]</code>. Используется при создании динамических массивов. После успешного выделения памяти для каждого из элементов массива вызывается <em>конструктор по умолчанию</em>.</li>
</ol>
<p>Также, существует возможность выделять память при помощи функций языка C из библиотеки <code>&lt;cstdlib&gt;</code>:</p>
<ol class="arabic simple">
<li>Функция <code>malloc()</code>.  Память выделяется из сектора оперативной памяти доступного для любых программ, выполняемых на данной машине. Аргументом функции является количество байт памяти, которую необходимо выделить, возвращает функция — указатель на выделенный блок в памяти. Содержание выделенного блока памяти не инициализируется, оно остается с неопределенными значениями.</li>
<li>Функция <code>calloc()</code>. Выделяет блок памяти для массива размером — <code>num</code> элементов, каждый из которых занимает <code>size</code> байт. Содержание всех битов выделенного блока памяти инициализируется нулями.</li>
</ol>
<p>Освобождение памяти необходимо производить в соответствии с тем методом, как она была выделена:</p>
<ol class="arabic simple">
<li>Оператор <code>delete</code>. Освобождает память, выделенную оператором <code>new</code>.</li>
<li>Оператор <code>delete[]</code>. Освобождает всю память, занимаемую массивом.</li>
<li>Функция <code>free</code>. Освобождает блок памяти, ранее выделенный с помощью вызова <code>malloc</code>, <code>calloc</code>.</li>
</ol>
<p>При <code>delete</code> и <code>delete[]</code> для всех элементов массива вызываются <em>деструкторы</em>.</p>
<p>После освобождения памяти посредством вызова функции <code>free(ptr);</code>, хорошей практикой является сброс указателя, то есть провести присвоение <code>ptr = NULL;</code>. Если указателю присвоить <code>NULL</code> (или же <code>0</code>), указатель становится нулевым, т. е. он уже никуда не указывает. Всегда после высвобождения памяти, присваивайте указателю <code>NULL</code>, в противном случае, даже после высвобождения памяти, указатель все равно на неё указывает, а значит вы случайно можете нанести вред другим программам, которые, будут использовать эту память, но вы даже ничего об этом не узнаете и будете думать, что программа работает корректно.</p>
<p>Использование оператора <code>delete</code> на объекте, который не был создан при помощи оператора <code>new</code>, создаёт непрогнозируемый результат. Однако оператор <code>delete</code> может использоваться на указателе со значением <code>NULL</code>. Это означает, что, если оператор <code>new</code> возвращает <code>NULL</code> при сбое, то результат такой операции <code>new</code> можно удалить без опасных последствий.
Использование формы <code>delete[]</code> для удаления одиночного объекта и использование формы <code>delete</code> для удаления массива дают неопределенный результат.</p>
<p>Примеры использования функций:</p>
<p><code>new</code>/<code>delete</code>:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// динамическое выделение памяти под объект типа int</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// инициализация объекта через указатель</span>

  <span class="c1">// int *p = new int (10); инициализация может выполнятся сразу при объявлении динамического объекта</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"value = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">delete</span> <span class="n">p</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p><code>new[]</code>/<code>delete[]</code>:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Укажите кол-во элементов массива: "</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">len</span><span class="p">;</span>

  <span class="kt">int</span> <span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

   <span class="n">delete</span> <span class="p">[]</span> <span class="n">buffer</span><span class="p">;</span>                                     <span class="c1">// освобождаем память</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p><code>malloc</code>/<code>free</code>:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Укажите кол-во элементов массива: "</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">len</span><span class="p">;</span>

  <span class="kt">int</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>                       <span class="c1">// если выделение памяти не выполнилось, завершить программу</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>                                     <span class="c1">// освобождаем память</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p><code>calloc</code>/<code>free</code>:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Укажите кол-во элементов массива: "</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">len</span><span class="p">;</span>

  <span class="kt">int</span> <span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>                       <span class="c1">// если выделение памяти не выполнилось, завершить программу</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>                                     <span class="c1">// освобождаем память</span>
  <span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                                                                        <span class="c1">// зануляем указатель</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Рассмотрим фрагмент кода, в котором показано, как объявляется двумерный динамический массив.</p>
<div class="highlight"><pre><span></span><span class="kt">double</span> <span class="o">**</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">double</span><span class="o">*</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// две строки в массиве</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">double</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// и пять столбцов</span>
        <span class="c1">//  где ptr  – массив указателей на выделенный участок памяти под массив вещественных чисел типа double</span>
</pre></div>
<p>Сначала объявляется указатель второго порядка <code>double **ptr</code>, который ссылается на массив указателей  <code>double* [2]</code>, где размер массива равен двум. После чего в цикле <code>for</code> каждой строке массива объявленного в строке 2 выделяется память под пять элементов. В результате получается двумерный динамический массив  <code>ptr[2][5]</code>. Рассмотрим пример высвобождения памяти отводимой под двумерный динамический массив.</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">//где 2 – количество строк в массиве</span>
    <span class="n">delete</span> <span class="p">[]</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="n">delete</span><span class="p">[]</span> <span class="n">ptr</span><span class="p">;</span>
</pre></div>
<p>Объявление и удаление двумерного динамического массива выполняется с помощью цикла, так как показано выше, необходимо понять и  запомнить то,
как это делается. Разработаем программу, в которой создадим двумерный динамический массив.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">"stdafx.h"</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="o">**</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">double</span><span class="o">*</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// две строки в массиве</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">double</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// и пять столбцов</span>

    <span class="c1">// заполнение массива</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count_row</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">count_row</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count_column</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count_column</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">count_column</span><span class="p">)</span>
            <span class="n">ptr</span><span class="p">[</span><span class="n">count_row</span><span class="p">][</span><span class="n">count_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//заполнение массива случайными числами с масштабированием от 0 до 10</span>

    <span class="c1">// вывод массива</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count_row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count_row</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">count_row</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count_column</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count_column</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">count_column</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span><span class="p">[</span><span class="n">count_row</span><span class="p">][</span><span class="n">count_column</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"   "</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// удаление двумерного динамического массива</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">delete</span><span class="p">[]</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">delete</span><span class="p">[]</span> <span class="n">ptr</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id13">Утечка памяти</a></h2>
<p>Утечка памяти (англ. memory leak) — процесс неконтролируемого уменьшения объёма свободной оперативной памяти компьютера, связанный с ошибками в работающих программах, вовремя не освобождающих ненужные уже участки памяти, или с ошибками системных служб контроля памяти.</p>
<p>Рассмотрим пример:</p>
<div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">delete</span> <span class="p">[]</span> <span class="n">p</span><span class="p">;</span>
</pre></div>
<p>В этом примере с помощью <code>new</code> создается объект в динамической памяти. Вызов оператора <code>new</code> происходит 5 раз, причём каждый следующий раз адрес нового объекта перезаписывает значение, хранящееся в указателе <code>p</code>. Оператор <code>delete</code> выполняет удаление объекта, созданного на последней итерации цикла. Однако первые 4 объекта остаются в динамической памяти, и одновременно в программе не остаётся переменных, которые бы хранили адреса этих объектов. Т.е. после завершения цикла невозможно ни получить доступ к первым 4 объектам, ни удалить их.</p>
<p>В случае с двухмерными массивами сценарий удаления выглядит следующим образом:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="c1">// где row_count кол-во элементов в массиве</span>
    <span class="n">delete</span><span class="p">[]</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="n">delete</span><span class="p">[]</span> <span class="n">ptr</span><span class="p">;</span>
</pre></div>
<p>Если "забыть" про цикл или подставить значение <code>row_count</code> меньшее чем при выделении памяти или не удалить <code>ptr</code>, то память не будет освобождена.</p>
<p>Утечки памяти приводят к тому, что потребление памяти программой неконтролируемо возрастает, в результате рано или поздно вступают в действие архитектурные ограничения среды исполнения (операционной системы, виртуальной машины), и тогда новое выделение памяти становится невозможным. В этой ситуации в программе, которая запрашивает память, обычно происходит аварийная остановка. Это может по стечению обстоятельств произойти и совсем с другой программой после того, как программа, подверженная утечкам, исчерпает всю память.</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id14">Ошибка сегментации</a></h2>
<p>Ошибка сегментации (англ. Segmentation fault, сокр. segfault) — ошибка программного обеспечения, возникающая при попытке обращения к недоступным для записи участкам памяти либо при попытке изменения памяти запрещённым способом.</p>
<p>Пример ошибки сегментации при попытке записать в область памяти, предназначенную только для чтения:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">=</span> <span class="sc">'H'</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>В зависимости от компилятора и операционной системы ошибка возникнет либо после запуска программы:</p>
<div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">gcc</span> <span class="n">segfault</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">o</span> <span class="n">segfault</span>
<span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">segfault</span>
<span class="n">Segmentation</span> <span class="n">fault</span>
</pre></div>
<p>либо на этапе компиляции:</p>
<div class="highlight"><pre><span></span> <span class="err">$</span> <span class="n">gcc</span> <span class="n">segfault</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">o</span> <span class="n">segfault</span>
<span class="n">segfault</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">‘</span><span class="n">main</span><span class="err">’</span><span class="o">:</span>
<span class="n">segfault</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">3</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">assignment</span> <span class="n">of</span> <span class="n">read</span><span class="o">-</span><span class="n">only</span> <span class="n">location</span>
</pre></div>
<p>Чаще всего ошибка сегментации происходит потому, что указатель или нулевой, или указывает на произвольный участок памяти (возможно, потому что не был инициализирован), или указывает на удаленный участок памяти:</p>
<div class="highlight"><pre><span></span><span class="kt">char</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="cm">/* инициализирован как нулевой, в чем нет ничего плохого, но на многих системах он не может быть разыменован */</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">p2</span><span class="p">;</span>  <span class="cm">/* вообще не инициализирован */</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">p3</span>  <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>  <span class="cm">/* хорошо, участок памяти выделен */</span>

<span class="n">free</span><span class="p">(</span><span class="n">p3</span><span class="p">);</span>  <span class="cm">/* но теперь его больше нет */</span>
</pre></div>
<p>Теперь разыменование любого из этих указателей может вызвать ошибку сегментации:</p>
<div class="highlight"><pre><span></span><span class="c1">// Ошибка сегментации может возникнуть в любой из этих трех строчек</span>
<span class="kt">char</span> <span class="n">c1</span> <span class="o">=</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">c2</span> <span class="o">=</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">c3</span> <span class="o">=</span> <span class="o">*</span><span class="n">p3</span><span class="p">;</span>
</pre></div>
<p>Ошибка сегментации может возникнуть при использовании массивов, если случайно указать в качестве размера массива неинициализированную переменную:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="k">const</span> <span class="n">nmax</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="c1">// значение переменной n не задано</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="valgrind">
<h2><a class="toc-backref" href="#id15">Valgrind</a></h2>
<p>Valgrind хорошо известен как мощное средство поиска ошибок работы с памятью. Но кроме этого, в его составе имеется некоторое количество дополнительных утилит, предназначенных для профилирования программ, анализа потребления памяти и поиска ошибок связанных с синхронизацией в многопоточных программах.
Работа с <code>valgrind</code> достаточно проста -- его поведение полностью управляется опциями командной строки, а также не требует специальной подготовки программы, которую необходимо проанализировать (Хотя все-таки рекомендуется пересобрать программу с отладочной информацией и отключенной оптимизацией используя флаги компиляции <code>-g</code> и <code>-O0</code>). Если программа запускается командой "программа аргументы", то для ее запуска под управлением <code>valgrind</code>, необходимо в начало этой командной строки добавить слово <code>valgrind</code>, и указать опции, необходимые для его работы.</p>
<p>Например, так:</p>
<div class="highlight"><pre><span></span><span class="n">valgrind</span> <span class="o">--</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">full</span> <span class="o">--</span><span class="n">leak</span><span class="o">-</span><span class="n">resolution</span><span class="o">=</span><span class="n">med</span> <span class="err">программа</span> <span class="err">аргументы</span>
</pre></div>
<p>что приведет к запуску нужной программы c заданными аргументами, и для нее будет проведен поиск утечек памяти. Если в проекте нет утечки памяти, вывод будет похож на этот</p>
<div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">HEAP</span> <span class="nl">SUMMARY</span><span class="p">:</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">16</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">total</span> <span class="n">heap</span> <span class="nl">usage</span><span class="p">:</span> <span class="mi">5</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">4</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">80</span> <span class="n">bytes</span> <span class="n">allocated</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">LEAK</span> <span class="nl">SUMMARY</span><span class="p">:</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">definitely</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">16</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">indirectly</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">possibly</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">still</span> <span class="nl">reachable</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="nl">suppressed</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">Rerun</span> <span class="n">with</span> <span class="err">—</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">full</span> <span class="n">to</span> <span class="n">see</span> <span class="n">details</span> <span class="n">of</span> <span class="n">leaked</span> <span class="n">memory</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">For</span> <span class="n">counts</span> <span class="n">of</span> <span class="n">detected</span> <span class="n">and</span> <span class="n">suppressed</span> <span class="n">errors</span><span class="p">,</span> <span class="n">rerun</span> <span class="nl">with</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">ERROR</span> <span class="nl">SUMMARY</span><span class="p">:</span> <span class="mi">0</span> <span class="n">errors</span> <span class="n">from</span> <span class="mi">0</span> <span class="n">contexts</span> <span class="p">(</span><span class="nl">suppressed</span><span class="p">:</span> <span class="mi">0</span> <span class="n">from</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1234</span> <span class="err">—</span> <span class="err">идентификатор</span> <span class="err">процесса</span> <span class="err">в</span> <span class="err">системе</span><span class="p">,</span> <span class="err">он</span> <span class="err">будет</span> <span class="err">отличаться</span> <span class="err">от</span> <span class="err">запуска</span> <span class="err">к</span> <span class="err">запуску</span><span class="p">.)</span>
</pre></div>
<p>В случае если память выделенная <code>new</code> не освобождается, то при запуске <code>valgrind</code> будет показан список вызовов <code>new</code> которые не имеют последующих вызовов <code>delete</code>. Рассмотрим пример:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ix</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">char</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>При использовании <code>valgrind</code> будет показано:</p>
<div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">HEAP</span> <span class="nl">SUMMARY</span><span class="p">:</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">5</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">total</span> <span class="n">heap</span> <span class="nl">usage</span><span class="p">:</span> <span class="mi">1</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">0</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">5</span> <span class="n">bytes</span> <span class="n">allocated</span>
</pre></div>
<p>Eсли мы перекомпилировать код с отладочной информацией (добавлением параметра <code>-g</code> в <code>g++</code>), мы получим более полезную информацию:</p>
<div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">15635</span><span class="o">==</span> <span class="n">HEAP</span> <span class="nl">SUMMARY</span><span class="p">:</span>
<span class="o">==</span><span class="mi">15635</span><span class="o">==</span> <span class="n">in</span> <span class="n">use</span> <span class="n">at</span> <span class="nl">exit</span><span class="p">:</span> <span class="mi">5</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span>
<span class="o">==</span><span class="mi">15635</span><span class="o">==</span> <span class="n">total</span> <span class="n">heap</span> <span class="nl">usage</span><span class="p">:</span> <span class="mi">1</span> <span class="n">allocs</span><span class="p">,</span> <span class="mi">0</span> <span class="n">frees</span><span class="p">,</span> <span class="mi">5</span> <span class="n">bytes</span> <span class="n">allocated</span>
<span class="o">==</span><span class="mi">15635</span><span class="o">==</span>
<span class="o">==</span><span class="mi">15635</span><span class="o">==</span> <span class="mi">10</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">1</span> <span class="n">blocks</span> <span class="n">are</span> <span class="n">definitely</span> <span class="n">lost</span> <span class="n">in</span> <span class="n">loss</span> <span class="n">record</span> <span class="mi">1</span> <span class="n">of</span> <span class="mi">1</span>
<span class="o">==</span><span class="mi">15635</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4C2BAD7</span><span class="o">:</span> <span class="n">operator</span> <span class="n">new</span><span class="p">[](</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">363</span><span class="p">)</span>
<span class="o">==</span><span class="mi">15635</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400575</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">man</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
<p>Теперь мы знаем точную строку, где был вызов new — man.cpp:3. Хотя отслеживание места, где необходимо освободить память, еще под вопросом, по крайней мере, становится понятно, с чего начать поиск.
Иногда <code>--leak-check=yes</code> не показывает все утечки памяти. Чтобы найти абсолютно все непарные вызовы <code>new</code>, необходимо использовать <code>--show-reachable=yes</code>. Вывод программы будет почти точно такой же, но он будет показывать больше не освобождённой памяти.</p>
<p>Valgrind может также показывать неверное использование памяти с помощью инструмента <code>Memcheck</code>. Например, если выделить массив используя <code>new</code>, а затем попытаться получить доступ к элементу за пределами массива:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">char</span> <span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="n">ptr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Скомпилируем в <code>g++</code>  этот исходник и в терминале вводим команду запуска <code>valgrind</code>:</p>
<div class="highlight"><pre><span></span><span class="n">g</span><span class="o">++</span> <span class="o">-</span><span class="n">g</span> <span class="n">myprog</span><span class="p">.</span><span class="n">cpp</span>
<span class="n">valgrind</span> <span class="err">—</span><span class="n">tool</span><span class="o">=</span><span class="n">memcheck</span> <span class="err">—</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">yes</span> <span class="err">‘</span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">student</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="err">’</span>
</pre></div>
<p>В получим следующую информацию:</p>
<div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">write</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">1</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x400582</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">man</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">Address</span> <span class="mh">0x5a0504a</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">after</span> <span class="n">a</span> <span class="n">block</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">5</span> <span class="n">alloc</span><span class="err">’</span><span class="n">d</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4C2BAD7</span><span class="o">:</span> <span class="n">operator</span> <span class="n">new</span><span class="p">[](</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">363</span><span class="p">)</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400575</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">man</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
<p>Данный вывод указывает на то, что используется указатель, выделенный для 5 байт, за пределами этого диапазона и происходит <code>Invalid write</code>. Если бы программа пыталась читать из этой памяти, то предупреждение было бы <code>Invalid read of size num</code>, где <code>num</code> — это объем памяти, который программа пытается прочитать. (Для <code>char</code> это будет один, а для <code>int</code> это будет либо 2, либо 4, в зависимости разрядности системы.)
Valgrind также выводит трассировку стека вызовов функций, так что точно известно, где произошла ошибка.</p>
<p>Другой тип операции, которую обнаруживает Valgrind, это использование неинициализированного значения в условном операторе. Например, выполнив следующий код:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"num == 1"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>через Valgrind, получим следующий ответ:</p>
<div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">Conditional</span> <span class="n">jump</span> <span class="n">or</span> <span class="n">move</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">uninitialised</span> <span class="n">value</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4006E0</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">man</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
<p>Valgrind достаточно умен, чтобы знать, что, если переменной не присваивается значение, то эта переменная все еще находится в «неинициализированном» состоянии, а значит никаких операций с ней быть не должно, до тех пор пока она не инициализируется. Например, выполнив следующий код:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

    <span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val &lt; 0"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
        <span class="n">func</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
<p>в Valgrind, результом будет следующее предупреждение:</p>
<div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">Conditional</span> <span class="n">jump</span> <span class="n">or</span> <span class="n">move</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">uninitialised</span> <span class="n">value</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">at</span> <span class="mh">0x4006E3</span><span class="o">:</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">man</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>
<span class="o">==</span><span class="mi">1234</span><span class="o">==</span> <span class="n">by</span> <span class="mh">0x400707</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">man</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
<p>Из вывода <code>valgrind</code> следует, что проблема была в <code>func</code>, и что остальная часть вызовов стека, вероятно, не так уж важна. Но так как main предоставляет неинициализированное значение в <code>func</code> (не присваивается значение <code>num</code>), то необходимо начать искать и отслеживать путь присвоения переменных, пока не будет найдена неициализированная переменная. Это будет обнаружено только если на самом деле будет вызвана та ветвь кода, и, в частности, тот условный оператор.</p>
<p>Valgrind также умеет обнаруживать другие случаи неправильного использования памяти: если вызывается <code>delete</code> дважды с одним и тем же значением указателя, то выводится следующее сообщение:</p>
<div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">16441</span><span class="o">==</span> <span class="n">Invalid</span> <span class="n">free</span><span class="p">()</span> <span class="o">/</span> <span class="n">delete</span> <span class="o">/</span> <span class="n">delete</span><span class="p">[]</span> <span class="o">/</span> <span class="n">realloc</span><span class="p">()</span>
</pre></div>
<p>Valgrind не выполняет проверку границ в статических массивах (выделенных в стеке). Так что если объявить массив внутри функции:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'c'</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>то Valgrind не предупредит о выходе за пределы массива. Одно из возможных решений для тестирования — просто изменить статические массивы на динамически выделяемые, где будет проанализирована проверка на границы, хотя это может внести дополнительную путаницу связанную с вызовами <code>delete</code>.</p>
</div>
<div class="section" id="addresssanitizer">
<h2><a class="toc-backref" href="#id16">AddressSanitizer</a></h2>
<p>AddressSanitizer — библиотека, разработанная компанией Google, предназначенная для поиска следующих ошибок при работе с памятью:</p>
<ol class="arabic simple">
<li>Использование указателя после освобождения памяти.</li>
<li>Выход за пределы массива, выделенного в куче.</li>
<li>Выход за пределы массива, выделенного в стеке.</li>
<li>Выход за пределы глобального массива.</li>
<li>Передача указателя на локальную переменную функции в return.</li>
<li>Использование указателя на переменную за пределами ее области видимости.</li>
<li>Утечки памяти.</li>
</ol>
<p>Рассмотрим пример:</p>
<div class="highlight"><pre><span></span><span class="c1">// g++ -O -g -fsanitize=address myprog.cpp</span>
<span class="c1">// ./a.out</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="n">delete</span> <span class="p">[]</span> <span class="n">array</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">argc</span><span class="p">];</span>  <span class="c1">// BOOM</span>
<span class="p">}</span>
</pre></div>
<p>В результате работы программы будет выдан следующая информация, указывающая на использование указателя после его удаления:</p>
<div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">26775</span><span class="o">==</span><span class="nl">ERROR</span><span class="p">:</span> <span class="nl">AddressSanitizer</span><span class="p">:</span> <span class="n">heap</span><span class="o">-</span><span class="n">use</span><span class="o">-</span><span class="n">after</span><span class="o">-</span><span class="n">free</span> <span class="n">on</span> <span class="n">address</span> <span class="mh">0xb5d03e44</span> <span class="n">at</span> <span class="n">pc</span> <span class="mh">0x08048637</span> <span class="n">bp</span> <span class="mh">0xbfc4ac28</span> <span class="n">sp</span> <span class="mh">0xbfc4ac18</span>
<span class="n">READ</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">4</span> <span class="n">at</span> <span class="mh">0xb5d03e44</span> <span class="kr">thread</span> <span class="n">T0</span>
    <span class="cp">#0 0x8048636 in main test.cpp:4</span>
    <span class="cp">#1 0xb7090636 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18636)</span>
    <span class="cp">#2 0x8048500  (/home/pashkoff/a.out+0x8048500)</span>

<span class="mh">0xb5d03e44</span> <span class="n">is</span> <span class="n">located</span> <span class="mi">4</span> <span class="n">bytes</span> <span class="n">inside</span> <span class="n">of</span> <span class="mi">400</span><span class="o">-</span><span class="n">byte</span> <span class="n">region</span> <span class="p">[</span><span class="mh">0xb5d03e40</span><span class="p">,</span><span class="mh">0xb5d03fd0</span><span class="p">)</span>
<span class="n">freed</span> <span class="n">by</span> <span class="kr">thread</span> <span class="n">T0</span> <span class="nl">here</span><span class="p">:</span>
    <span class="cp">#0 0xb72c6434 in operator delete[](void*) (/usr/lib/i386-linux-gnu/libasan.so.2+0x98434)</span>
    <span class="cp">#1 0x804860b in main test.cpp:3</span>
    <span class="cp">#2 0xb7090636 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18636)</span>

<span class="n">previously</span> <span class="n">allocated</span> <span class="n">by</span> <span class="kr">thread</span> <span class="n">T0</span> <span class="nl">here</span><span class="p">:</span>
    <span class="cp">#0 0xb72c5e46 in operator new[](unsigned int) (/usr/lib/i386-linux-gnu/libasan.so.2+0x97e46)</span>
    <span class="cp">#1 0x80485f9 in main test.cpp:2</span>
    <span class="cp">#2 0xb7090636 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18636)</span>

<span class="nl">SUMMARY</span><span class="p">:</span> <span class="nl">AddressSanitizer</span><span class="p">:</span> <span class="n">heap</span><span class="o">-</span><span class="n">use</span><span class="o">-</span><span class="n">after</span><span class="o">-</span><span class="n">free</span> <span class="n">test</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">4</span> <span class="n">main</span>
<span class="n">Shadow</span> <span class="n">bytes</span> <span class="n">around</span> <span class="n">the</span> <span class="n">buggy</span> <span class="nl">address</span><span class="p">:</span>
  <span class="mh">0x36ba0770</span><span class="o">:</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span>
  <span class="mh">0x36ba0780</span><span class="o">:</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span>
  <span class="mh">0x36ba0790</span><span class="o">:</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span>
  <span class="mh">0x36ba07a0</span><span class="o">:</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span>
  <span class="mh">0x36ba07b0</span><span class="o">:</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span>
<span class="o">=&gt;</span><span class="mh">0x36ba07c0</span><span class="o">:</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span>
  <span class="mh">0x36ba07d0</span><span class="o">:</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span>
  <span class="mh">0x36ba07e0</span><span class="o">:</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span>
  <span class="mh">0x36ba07f0</span><span class="o">:</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fd</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span>
  <span class="mh">0x36ba0800</span><span class="o">:</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span>
  <span class="mh">0x36ba0810</span><span class="o">:</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span> <span class="n">fa</span>
<span class="n">Shadow</span> <span class="n">byte</span> <span class="n">legend</span> <span class="p">(</span><span class="n">one</span> <span class="n">shadow</span> <span class="n">byte</span> <span class="n">represents</span> <span class="mi">8</span> <span class="n">application</span> <span class="n">bytes</span><span class="p">)</span><span class="o">:</span>
  <span class="nl">Addressable</span><span class="p">:</span>           <span class="mo">00</span>
  <span class="n">Partially</span> <span class="nl">addressable</span><span class="p">:</span> <span class="mo">01</span> <span class="mo">02</span> <span class="mo">03</span> <span class="mo">04</span> <span class="mo">05</span> <span class="mo">06</span> <span class="mo">07</span>
  <span class="n">Heap</span> <span class="n">left</span> <span class="nl">redzone</span><span class="p">:</span>       <span class="n">fa</span>
  <span class="n">Heap</span> <span class="n">right</span> <span class="nl">redzone</span><span class="p">:</span>      <span class="n">fb</span>
  <span class="n">Freed</span> <span class="n">heap</span> <span class="nl">region</span><span class="p">:</span>       <span class="n">fd</span>
  <span class="n">Stack</span> <span class="n">left</span> <span class="nl">redzone</span><span class="p">:</span>      <span class="n">f1</span>
  <span class="n">Stack</span> <span class="n">mid</span> <span class="nl">redzone</span><span class="p">:</span>       <span class="n">f2</span>
  <span class="n">Stack</span> <span class="n">right</span> <span class="nl">redzone</span><span class="p">:</span>     <span class="n">f3</span>
  <span class="n">Stack</span> <span class="n">partial</span> <span class="nl">redzone</span><span class="p">:</span>   <span class="n">f4</span>
  <span class="n">Stack</span> <span class="n">after</span> <span class="k">return</span><span class="o">:</span>      <span class="n">f5</span>
  <span class="n">Stack</span> <span class="n">use</span> <span class="n">after</span> <span class="nl">scope</span><span class="p">:</span>   <span class="n">f8</span>
  <span class="n">Global</span> <span class="nl">redzone</span><span class="p">:</span>          <span class="n">f9</span>
  <span class="n">Global</span> <span class="n">init</span> <span class="nl">order</span><span class="p">:</span>       <span class="n">f6</span>
  <span class="n">Poisoned</span> <span class="n">by</span> <span class="nl">user</span><span class="p">:</span>        <span class="n">f7</span>
  <span class="n">Container</span> <span class="nl">overflow</span><span class="p">:</span>      <span class="n">fc</span>
  <span class="n">Array</span> <span class="nl">cookie</span><span class="p">:</span>            <span class="n">ac</span>
  <span class="n">Intra</span> <span class="n">object</span> <span class="nl">redzone</span><span class="p">:</span>    <span class="n">bb</span>
  <span class="n">ASan</span> <span class="nl">internal</span><span class="p">:</span>           <span class="n">fe</span>
<span class="o">==</span><span class="mi">26775</span><span class="o">==</span><span class="n">ABORTING</span>
</pre></div>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id17">Задания</a></h2>
<div class="section" id="id8">
<h3><a class="toc-backref" href="#id18">Умнножение матрицу</a></h3>
<ol class="arabic simple">
<li>Напишите программу, которая принимает на вход числа <code>M</code>, <code>N</code>, <code>K</code>, выделяет память под матрицу размером <code>MxN</code> типа <code>double</code> используя <code>malloc</code>, и <code>NxK</code> типа <code>int</code> используя <code>calloc</code> и <code>MxK</code> типа <code>double</code> используя <code>new[]</code>.</li>
<li>Инициализирует элементы первой матрицы по правилу x<sub>ij</sub>= i + j.</li>
<li>Инициализирует элементы второй матрицы по правилу x<sub>ij</sub>= 1 если <code>i == j</code>, 0 если <code>i != j</code>.</li>
<li>Записывает в третью матрицу результат умножения первых двух и распечатывает результат.</li>
<li>Освобождает выделенную память.</li>
<li>Используя Valgrind убедитесь, что нигде не происходит утечек памяти и выхода за пределы массивов.</li>
<li>Используя AddressSanitizer убедитесь, что нигде не происходит утечек памяти и выхода за пределы массивов.</li>
<li>Закомментируйте освобождение памяти и посмотрите, как изменится вывод утилит Valgrind и AddressSanitizer.</li>
<li>В коде программы обратитесь за границы одного из выделенных массивов и проанализируйте вывод утилит Valgrind и AddressSanitizer.</li>
</ol>
</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id19">Треугольник Паскаля</a></h3>
<p>Выделите память под <strong>треугольную матрицу</strong> и заполните её, как <a class="reference external" href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_%D0%9F%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D1%8F">Треугольник Паскаля</a>.</p>
</div>
</div>

    </div><!-- /.entry-content -->

  </article>
</section>
                <section id="extras" class="body">
                </section><!-- /#extras -->
            </div>
        </div>

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Сайт построен с использованием <a href="http://getpelican.com/">Pelican</a>. За основу оформления взята тема от <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>. Исходные тексты программ, приведённые на этом сайте, распространяются под лицензией <a href="http://www.gnu.org/licenses/quick-guide-gplv3.en.html">GPLv3</a>, все остальные материалы сайта распространяются под лицензией <a href="http://creativecommons.org/licenses/by-sa/3.0/deed.ru">CC-BY-SA</a>.
                </address><!-- /#about -->
        </footer><!-- /#contentinfo -->

<script type="text/javascript">//<![CDATA[
//  var code_blocks = Array.prototype.slice.call(document.getElementsByClassName('highlight'));
//  var solutions = code_blocks.filter(function(e, i, z){
//    return (e.parentElement.firstElementChild.tagName == 'H3' || e.parentElement.firstElementChild.tagName == 'H2') &&
//           e.parentElement.firstElementChild.firstChild.text.startsWith('Упражнение') &&
//           e.parentElement.lastElementChild == e
//  })
//  for (var i in solutions)
//  {
//  //    solutions[i].remove();
//  //  }
//]]>
</script>
</body>
</html>